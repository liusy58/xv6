diff --git a/README b/README
index 06035bb..f60d181 100644
--- a/README
+++ b/README
@@ -43,3 +43,11 @@ You will need a RISC-V "newlib" tool chain from
 https://github.com/riscv/riscv-gnu-toolchain, and qemu compiled for
 riscv64-softmmu. Once they are installed, and in your shell
 search path, you can run "make qemu".
+
+
+
+usertrap(): unexpected scause 0x000000000000000c pid=1
+            sepc=0x0000000000000f7c stval=0x0000000000001000
+panic: init exiting
+为什么会出现init退出的现象呢？
+
diff --git a/kernel/defs.h b/kernel/defs.h
index 9e45675..b9d1290 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -64,12 +64,12 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+void            init_mem_ref();
 void            inc_mem_ref(uint64 );
 void            dec_mem_ref(uint64 );
 int             is_mem_ref_zero(uint64 );
 pte_t *
 walk(pagetable_t pagetable, uint64 va, int alloc);
-
 // log.c
 void            initlog(int, struct superblock*);
 void            log_write(struct buf*);
@@ -151,7 +151,7 @@ void            trapinit(void);
 void            trapinithart(void);
 extern struct spinlock tickslock;
 void            usertrapret(void);
-
+int             page_fault_handler(pagetable_t ,uint64 );
 // uart.c
 void            uartinit(void);
 void            uartintr(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index 0e8762f..2bc7b09 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -96,7 +96,7 @@ exec(char *path, char **argv)
     goto bad;
   if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
     goto bad;
-
+  printf("in exec and copyout is ok~\n");
   // arguments to user main(argc, argv)
   // argc is returned via the system call return
   // value, which goes in a0.
@@ -115,7 +115,7 @@ exec(char *path, char **argv)
   p->trapframe->epc = elf.entry;  // initial program counter = main
   p->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
-
+  //printf("in exec\n");
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
  bad:
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 5226485..7a1f15c 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -9,7 +9,7 @@
 #include "riscv.h"
 #include "defs.h"
 
-
+int ok =0;
 
 void freerange(void *pa_start, void *pa_end);
 
@@ -34,8 +34,10 @@ struct ref{
 void
 kinit()
 {
+  init_mem_ref();
   initlock(&kmem.lock, "kmem");
   freerange(end, (void*)PHYSTOP);
+  ok=1;
 }
 
 void
@@ -44,6 +46,7 @@ freerange(void *pa_start, void *pa_end)
   char *p;
   p = (char*)PGROUNDUP((uint64)pa_start);
   for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE){
+    inc_mem_ref((uint64)p);
     kfree(p);
   }
 }
@@ -59,12 +62,11 @@ kfree(void *pa)
 
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
-  if(PTE_FLAGS(PA2PTE(pa))&PTE_C){
-    dec_mem_ref((uint64)pa);
-    if(!is_mem_ref_zero((uint64)pa)){
-      return;
-    }
+  dec_mem_ref((uint64)pa);
+  if(!is_mem_ref_zero((uint64)pa)){
+    return;
   }
+  
   // Fill with junk to catch dangling refs.
   memset(pa, 1, PGSIZE);
 
@@ -90,25 +92,34 @@ kalloc(void)
     kmem.freelist = r->next;
   release(&kmem.lock);
 
-  if(r)
+  if(r){
     memset((char*)r, 5, PGSIZE); // fill with junk
-  inc_mem_ref((uint64)r);  
+    inc_mem_ref((uint64)r);  
+  }
   return (void*)r;
 }
 
-
+void init_mem_ref(){
+  initlock(&page_ref.lock,"page_ref");
+  acquire(&page_ref.lock);
+  for(int i=0;i<PHYSTOP>>12;++i)
+    page_ref.count[i]=0;
+  release(&page_ref.lock);
+}
 
 void inc_mem_ref(uint64 pa){
   acquire(&page_ref.lock);
   page_ref.count[pa>>12]+=1;
-  printf("inc_mem_ref the address %p and now the ref is %d\n",pa,page_ref.count[(uint64)pa>>12]);
+  // if(ok)
+  //   printf("inc_mem_ref the address %p and now the ref is %d\n",pa,page_ref.count[(uint64)pa>>12]);
   release(&page_ref.lock);
 }
 
 void dec_mem_ref(uint64 pa){
   acquire(&page_ref.lock);
   page_ref.count[pa>>12]-=1;
-  printf("dec_mem_ref the address %p and now the ref is %d\n",pa,page_ref.count[(uint64)pa>>12]);
+  // if(ok)
+  //   printf("dec_mem_ref the address %p and now the ref is %d\n",pa,page_ref.count[(uint64)pa>>12]);
   release(&page_ref.lock);
 }
 
diff --git a/kernel/trap.c b/kernel/trap.c
index cdaee9e..a0b2aaa 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -16,6 +16,31 @@ void kernelvec();
 
 extern int devintr();
 
+
+void vmprint_help(pagetable_t pagetable,int depth){
+  if(depth>3)
+    return;
+  for(int i = 0; i < 512; i++){
+    pte_t pte = pagetable[i];
+    if(pte & PTE_V){
+      // this PTE points to a lower-level page table.
+      uint64 child = PTE2PA(pte);
+      for(int j=1;j<=depth;++j){
+        printf("..%s",j==depth?"":" ");
+      }
+      printf("%d: pte %p pa %p\n",i,pte,child);
+
+      vmprint_help((pagetable_t)child,depth+1);
+    } 
+  }
+}
+
+void vmprint(pagetable_t pagetable){
+  printf("page table %p\n",pagetable);
+  vmprint_help(pagetable,1);
+}
+
+
 void
 trapinit(void)
 {
@@ -31,25 +56,35 @@ trapinithart(void)
 
 
 
-int page_fault_handler(){
-  uint64 address = r_stval();
+int page_fault_handler(pagetable_t pagetable,uint64 address){
+  //printf("handler page fault %p\n",address);
+  address = PGROUNDDOWN(address);
   pte_t *pte;
   uint64 pa;
   uint flags;
-  pte = walk(myproc()->pagetable, address, 0);
+  pte = walk(pagetable, address, 0);
+  if(pte==0){
+    return -1;
+  }
   pa = PTE2PA(*pte);
+  if(pa==0)
+    return -1;
   flags = PTE_FLAGS(*pte);
   if(flags&PTE_C){
-    flags = flags&(PTE_W)&(~PTE_C);
+    flags = (flags|PTE_W)&(~PTE_C);
     char *mem;
     if((mem = kalloc()) != 0){
       memmove(mem, (char*)pa, PGSIZE);
       *pte = PA2PTE(mem) | flags;
-      dec_mem_ref(pa);
+      kfree((void*)pa);
       return 0;
+    }else{
+      return -1;
     }
   }
-  return -1;
+  //printf("the PTE_C is not set~~\n");
+  //vmprint(myproc()->pagetable);
+  return 0;
 }
 
 
@@ -94,19 +129,28 @@ usertrap(void)
     // ok
   } else {
     if(r_scause()==13||r_scause()==15){
-      if(page_fault_handler()!=0){
+      if(r_stval()>=MAXVA||(r_stval()<=PGROUNDDOWN(p->trapframe->sp)&&r_stval()>=PGROUNDDOWN(p->trapframe->sp)-PGSIZE)){
+        printf("r_stval ");
+         p->killed=1;
+      }
+      else if(page_fault_handler(p->pagetable,r_stval())!=0){
+        printf("page handle returned not 0\n");
         p->killed=1;
-      }else{
+      }
+    }else{
         printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
         printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+        
         p->killed = 1;
       }
-    }
   }
 
-  if(p->killed)
+  if(p->killed){
+    vmprint(p->pagetable);
     exit(-1);
 
+  }
+
   // give up the CPU if this is a timer interrupt.
   if(which_dev == 2)
     yield();
@@ -169,7 +213,7 @@ kerneltrap()
   uint64 sepc = r_sepc();
   uint64 sstatus = r_sstatus();
   uint64 scause = r_scause();
-  
+     
   if((sstatus & SSTATUS_SPP) == 0)
     panic("kerneltrap: not from supervisor mode");
   if(intr_get() != 0)
diff --git a/kernel/vm.c b/kernel/vm.c
index 2866cab..ecf0c87 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -322,8 +322,12 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
     if((*pte & PTE_V) == 0)
       panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
-    flags = (PTE_FLAGS(*pte)&(~PTE_W))|PTE_C;
-    *pte = PA2PTE(pa) | flags;
+    flags = PTE_FLAGS(*pte);
+    if(flags&PTE_W){
+      flags = (flags|(~PTE_W))|PTE_C; 
+      *pte = PA2PTE(pa) | flags;
+    }
+    
     inc_mem_ref(pa);
     // if((mem = kalloc()) == 0)
     //   goto err;
@@ -366,29 +370,23 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
+    if(va0>=MAXVA||(va0<=PGROUNDDOWN(myproc()->trapframe->sp)&&va0>=PGROUNDDOWN(myproc()->trapframe->sp)-PGSIZE))
+      return -1;
+    if(page_fault_handler(pagetable,dstva)!=0){
+      printf("in copyout and return -1;\n");
+      return -1;
+    }
     pa0 = walkaddr(pagetable, va0);
     if(pa0 == 0)
       return -1;
-    if(PA2PTE(pa0)&PTE_C){
-      pte_t *pte= (pte_t *)PA2PTE(pa0);
-      uint64  flags = PTE_FLAGS(*pte);
-      flags = flags&(PTE_W)&(~PTE_C);
-      char *mem;
-      if((mem = kalloc()) != 0){
-        memmove(mem, (char*)pa0, PGSIZE);
-        *pte = PA2PTE(mem) | flags;
-      }
-      dec_mem_ref(pa0);
-      pa0 = walkaddr(pagetable,va0);
-    }
     n = PGSIZE - (dstva - va0);
     if(n > len)
       n = len;
     memmove((void *)(pa0 + (dstva - va0)), src, n);
-
     len -= n;
     src += n;
     dstva = va0 + PGSIZE;
+    printf("in copyout and memmove is ok and len is %d\n",len);
   }
   return 0;
 }
diff --git a/user/cowtest.c b/user/cowtest.c
index 29b918f..b02c122 100644
--- a/user/cowtest.c
+++ b/user/cowtest.c
@@ -12,6 +12,7 @@
 void
 simpletest()
 {
+  printf("in simpletest\n");
   uint64 phys_size = PHYSTOP - KERNBASE;
   int sz = (phys_size / 3) * 2;
 
